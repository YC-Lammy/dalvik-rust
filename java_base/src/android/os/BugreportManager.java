/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.os;

import android.annotation.IntDef;
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.annotation.RequiresPermission;
import android.annotation.SystemApi;
import android.annotation.SystemService;
import android.content.Context;
import android.util.Log;

import android.R;
import android.util.internal.Preconditions;

import libcore.io.IoUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.concurrent.Executor;

/**
 * Class that provides a privileged API to capture and consume bugreports.
 *
 * <p>This class may only be used by apps that currently have carrier privileges (see {@link
 * android.telephony.TelephonyManager#hasCarrierPrivileges}) on an active SIM or priv-apps
 * explicitly allowed by the device manufacturer.
 *
 * <p>Only one bugreport can be generated by the system at a time.
 */
public final class BugreportManager {

    private static final String TAG = "BugreportManager";

    private final Context mContext;

    /** @hide */
    public BugreportManager(@NonNull Context context) {
        mContext = context;
    }

    /**
     * An interface describing the callback for bugreport progress and status.
     *
     * <p>Callers will receive {@link #onProgress} calls as the bugreport progresses, followed by a
     * terminal call to either {@link #onFinished} or {@link #onError}.
     *
     * <p>If an issue is encountered while starting the bugreport asynchronously, callers will
     * receive an {@link #onError} call without any {@link #onProgress} callbacks.
     */
    public abstract static class BugreportCallback {

        /**
         * The input options were invalid. For example, the destination file the app provided could
         * not be written by the system.
         */
        public static final int BUGREPORT_ERROR_INVALID_INPUT = 1;

        /** A runtime error occurred. */
        public static final int BUGREPORT_ERROR_RUNTIME = 2;

        /** User denied consent to share the bugreport. */
        public static final int BUGREPORT_ERROR_USER_DENIED_CONSENT = 3;

        /** The request to get user consent timed out. */
        public static final int BUGREPORT_ERROR_USER_CONSENT_TIMED_OUT = 4;

        /** There is currently a bugreport running. The caller should try again later. */
        public static final int BUGREPORT_ERROR_ANOTHER_REPORT_IN_PROGRESS = 5;

        /**
         * Called when there is a progress update.
         *
         * @param progress the progress in [0.0, 100.0]
         */
        public void onProgress(float progress) {}

        /**
         * Called when taking bugreport resulted in an error.
         *
         * <p>If {@code BUGREPORT_ERROR_USER_DENIED_CONSENT} is passed, then the user did not
         * consent to sharing the bugreport with the calling app.
         *
         * <p>If {@code BUGREPORT_ERROR_USER_CONSENT_TIMED_OUT} is passed, then the consent timed
         * out, but the bugreport could be available in the internal directory of dumpstate for
         * manual retrieval.
         *
         * <p>If {@code BUGREPORT_ERROR_ANOTHER_REPORT_IN_PROGRESS} is passed, then the caller
         * should try later, as only one bugreport can be in progress at a time.
         */
        public void onError(int errorCode) {}

        /** Called when taking bugreport finishes successfully. */
        public void onFinished() {}

        /**
         * Called when it is ready for calling app to show UI, showing any extra UI before this
         * callback can interfere with bugreport generation.
         */
        public void onEarlyReportFinished() {}
    }

    /**
     * Starts a connectivity bugreport.
     *
     * <p>The connectivity bugreport is a specialized version of bugreport that only includes
     * information specifically for debugging connectivity-related issues (e.g. telephony, wi-fi,
     * and IP networking issues). It is intended primarily for use by OEMs and network providers
     * such as mobile network operators. In addition to generally excluding information that isn't
     * targeted to connectivity debugging, this type of bugreport excludes PII and sensitive
     * information that isn't strictly necessary for connectivity debugging.
     *
     * <p>The calling app MUST have a context-specific reason for requesting a connectivity
     * bugreport, such as detecting a connectivity-related issue. This API SHALL NOT be used to
     * perform random sampling from a fleet of public end-user devices.
     *
     * <p>Calling this API will cause the system to ask the user for consent every single time. The
     * bugreport artifacts will be copied over to the given file descriptors only if the user
     * consents to sharing with the calling app.
     *
     * <p>This starts a bugreport in the background. However the call itself can take several
     * seconds to return in the worst case. {@code callback} will receive progress and status
     * updates.
     *
     * <p>Requires that the calling app has carrier privileges (see {@link
     * android.telephony.TelephonyManager#hasCarrierPrivileges}) on any active subscription.
     *
     * @param bugreportFd file to write the bugreport. This should be opened in write-only, append
     *     mode.
     * @param callback callback for progress and status updates.
     */
    public void startConnectivityBugreport(
            @NonNull ParcelFileDescriptor bugreportFd,
            @NonNull Executor executor,
            @NonNull BugreportCallback callback) {

    }

    /**
     * Cancels the currently running bugreport.
     *
     * <p>Apps are only able to cancel their own bugreports. App A cannot cancel a bugreport started
     * by app B.
     *
     * <p>Requires permission: {@link android.Manifest.permission#DUMP} or that the calling app has
     * carrier privileges (see {@link android.telephony.TelephonyManager#hasCarrierPrivileges}) on
     * any active subscription.
     *
     * @throws SecurityException if trying to cancel another app's bugreport in progress
     */
    public void cancelBugreport() {

    }
}
